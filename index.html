<!DOCTYPE html>
<html lang="en">
  <head>
    <title>MMMCommonCore  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>


    <a title="MMMCommonCore  Reference"></a>

    <header class="header">
      <a href="https://media.monks.com">
        <img src="img/logo.png" srcset="img/logo@2x.png 2x" alt="Media.Monks" class="header-logo" />
      </a>
    
      <p class="header-col header-col--primary"></p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/mediamonks/MMMCommonCore">
            <img class="header-icon" src="img/gh.png" alt="GitHub"/>
            View on GitHub
          </a>
        </p>
    
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html">MMMCommonCore</a>
      <img class="carat" src="img/carat.png" alt=""/>
      MMMCommonCore  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content top-matter">
            
            <h1 id='mmmcommoncore' class='heading'>MMMCommonCore</h1>

<p><a href="https://github.com/mediamonks/MMMCommonCore/actions?query=workflow%3ABuild"><img src="https://github.com/mediamonks/MMMCommonCore/workflows/Build/badge.svg" alt="Build"></a>
<a href="https://github.com/mediamonks/MMMCommonCore/actions?query=workflow%3ATest"><img src="https://github.com/mediamonks/MMMCommonCore/workflows/Test/badge.svg" alt="Test"></a></p>

<p>Small bits and pieces reused in many pods from MMMTemple.</p>

<p>(This is a part of <code>MMMTemple</code> suite of iOS libraries we use at <a href="https://www.mediamonks.com/">MediaMonks</a>.)</p>
<h2 id='installation' class='heading'>Installation</h2>

<p>Podfile:</p>
<pre class="highlight ruby"><code><span class="n">source</span> <span class="s1">'https://github.com/mediamonks/MMMSpecs.git'</span>
<span class="n">source</span> <span class="s1">'https://github.com/CocoaPods/Specs.git'</span>
<span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">pod</span> <span class="s1">'MMMCommonCore'</span>
</code></pre>

<p>(Use &lsquo;MMMCommonCore/ObjC&rsquo; when Swift wrappers are not needed.)</p>

<p>SPM:</p>
<pre class="highlight swift"><code><span class="o">.</span><span class="nf">package</span><span class="p">(</span><span class="nv">url</span><span class="p">:</span> <span class="s">"https://github.com/mediamonks/MMMCommonCore"</span><span class="p">,</span> <span class="o">.</span><span class="nf">upToNextMajor</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="s">"1.8.1"</span><span class="p">))</span>
</code></pre>
<h2 id='usage' class='heading'>Usage</h2>

<p>MMMCommonCore contains some concrete classes, global functions as well as extensions to 
Foundation &amp; native Swift types. There are also some Objective-C macro&rsquo;s available, have
a peek at <code>MMMCommonCore.h</code> for more info on that.</p>
<h3 id='mmmnetworkconditioner' class='heading'>MMMNetworkConditioner</h3>

<p>This is to help with network-related simulated delays and failures.</p>

<p><strong>Example:</strong></p>
<pre class="highlight swift"><code>
<span class="c1">// Somewhere in your setup code we initialize a network conditioner.</span>
<span class="c1">// You probably want to only fail and delay on debug builds, you can</span>
<span class="c1">// pass `nil` as the condition to avoid any delays or failures.</span>
<span class="k">self</span><span class="o">.</span><span class="n">conditioner</span> <span class="o">=</span> <span class="kt">MMMNetworkConditioner</span><span class="p">(</span>
    <span class="nv">condition</span><span class="p">:</span> <span class="kt">MMMSimpleNetworkCondition</span><span class="p">(</span>
        <span class="nv">minDelay</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="c1">// Delay all requests for at least 1 second.</span>
        <span class="nv">maxDelay</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="c1">// at most 5 seconds.</span>
        <span class="nv">failureRate</span><span class="p">:</span> <span class="mf">0.3</span> <span class="c1">// Fail 30% of the time.</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="c1">// This will also replace the shared instance, as long as the </span>
<span class="c1">// MMMNetworkConditioner is initialized exactly once.</span>
<span class="c1">//</span>
<span class="c1">// So we can use the shared() instance from now on.</span>
<span class="kt">MMMNetworkConditioner</span><span class="o">.</span><span class="nf">shared</span><span class="p">()</span><span class="o">.</span><span class="n">conditionBlock</span> <span class="p">{</span> <span class="n">err</span> <span class="k">in</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
        <span class="c1">// Result failed due to simulated error, this will happen 30% of the time.</span>
        <span class="n">promise</span><span class="o">.</span><span class="nf">fail</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">task</span> <span class="o">=</span> <span class="kt">URLSession</span><span class="o">.</span><span class="n">shared</span><span class="o">.</span><span class="nf">dataTask</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="n">myUrl</span><span class="p">)</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nv">error</span> <span class="o">=</span> <span class="n">error</span> <span class="p">{</span>
            <span class="c1">// Result actually failed.</span>
            <span class="n">promise</span><span class="o">.</span><span class="nf">fail</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="o">...</span>
    <span class="p">}</span>

    <span class="o">...</span>
<span class="p">}</span>
</code></pre>
<h3 id='mmmweakproxy' class='heading'>MMMWeakProxy</h3>

<p>This is to be able to cut strong references, such as the ones NSTimer creates to its
targets. The proxy will forward all method calls to the target, but at the same time
won&rsquo;t hold a reference to the target.</p>

<p><strong>Example:</strong></p>
<pre class="highlight swift"><code><span class="n">foo</span><span class="o">.</span><span class="nf">addTarget</span><span class="p">(</span><span class="kt">MMMWeakProxy</span><span class="p">(</span><span class="nv">target</span><span class="p">:</span> <span class="k">self</span><span class="p">),</span> <span class="nv">selector</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span>
</code></pre>
<h3 id='mmmtimesource' class='heading'>MMMTimeSource</h3>

<p>This to be able to test classes depending on real time. Default implementations are
<code>MMMMockTimeSource</code> and <code>MMMDefaultTimeSource</code>. <code>MMMMockTimeSource</code> is a time source 
for unit tests, where the &ldquo;now&rdquo; can be set externally and the scale or real time 
can be changed. <code>MMMDefaultTimeSource</code> is a regular (real time) time source.</p>
<pre class="highlight swift"><code><span class="kd">class</span> <span class="kt">Foo</span> <span class="p">{</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">timeSource</span><span class="p">:</span> <span class="kt">MMMTimeSource</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Current time. It might be frozen, but should never go back.</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Current time: "</span><span class="p">,</span> <span class="n">timeSource</span><span class="o">.</span><span class="n">now</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Use in app:</span>

<span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">Foo</span><span class="p">(</span><span class="nv">timeSource</span><span class="p">:</span> <span class="kt">MMMDefaultTimeSource</span><span class="p">())</span>

<span class="c1">// Use in tests:</span>

<span class="c1">// Now we can mock the time.</span>
<span class="k">let</span> <span class="nv">time</span> <span class="o">=</span> <span class="kt">MMMMockTimeSource</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">foo</span> <span class="o">=</span> <span class="kt">Foo</span><span class="p">(</span><span class="nv">timeSource</span><span class="p">:</span> <span class="n">time</span><span class="p">)</span>
</code></pre>
<h3 id='semver' class='heading'>SemVer</h3>

<p>Simple Semantic Versioning struct so you can easily compare 2 semantic versions.</p>

<p><strong>Example:</strong></p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">lower</span> <span class="o">=</span> <span class="kt">SemVer</span><span class="p">(</span><span class="nv">version</span><span class="p">:</span> <span class="s">"1.5.2"</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">higher</span> <span class="o">=</span> <span class="kt">SemVer</span><span class="p">(</span><span class="nv">major</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nv">minor</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nv">patch</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">lower</span> <span class="o">==</span> <span class="n">higher</span> <span class="c1">// false</span>
<span class="n">lower</span> <span class="o">&lt;</span> <span class="n">higher</span> <span class="c1">// true</span>
</code></pre>
<h3 id='arraybuilder' class='heading'>ArrayBuilder</h3>

<p>A <code>resultBuilder</code> to help with constructing arrays. This can be useful when you want to 
create an array, in order, that depends on a number of conditions.</p>

<p><strong>Example:</strong></p>
<pre class="highlight swift"><code><span class="c1">// For example populating an array of widgets (inside your ViewModel).</span>
<span class="k">self</span><span class="o">.</span><span class="n">widgets</span><span class="o">.</span><span class="n">build</span> <span class="p">{</span>
    <span class="kt">ProfileWidget</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">user</span><span class="p">)</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nv">avatar</span> <span class="o">=</span> <span class="nf">userAvatar</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">AvatarWidget</span><span class="p">(</span><span class="nv">avatar</span><span class="p">:</span> <span class="n">avatar</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="n">user</span><span class="o">.</span><span class="n">type</span> <span class="p">{</span>
    <span class="k">case</span> <span class="o">.</span><span class="nv">admin</span><span class="p">:</span>
        <span class="kt">AdminPanel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span>
        <span class="kt">DeveloperPanel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span>

    <span class="k">case</span> <span class="o">.</span><span class="nv">developer</span><span class="p">:</span>
        <span class="kt">DeveloperPanel</span><span class="p">(</span><span class="nv">user</span><span class="p">:</span> <span class="n">user</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Now <code>widgets.didSet</code> only get&rsquo;s called once, allowing you to trigger changes once.</p>

<p>The <code>ArrayBuilder</code> has some extensions on <code>Array</code> for ease of use:</p>
<pre class="highlight swift"><code><span class="c1">/// Rebuild the array using the ``ArrayBuilder``.</span>
<span class="k">mutating</span> <span class="kd">func</span> <span class="nf">build</span><span class="p">(</span><span class="kd">@ArrayBuilder</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="nv">builder</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">])</span>

<span class="c1">/// Rebuild the array using the ``ArrayBuilder``, returning a new array.</span>
<span class="kd">func</span> <span class="nf">building</span><span class="p">(</span><span class="kd">@ArrayBuilder</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="nv">builder</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">]</span>

<span class="c1">/// Append contents to the array using the ``ArrayBuilder``.</span>
<span class="k">mutating</span> <span class="kd">func</span> <span class="nf">append</span><span class="p">(</span><span class="kd">@ArrayBuilder</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="nv">builder</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">])</span>

<span class="c1">/// Append contents to the array using the ``ArrayBuilder``, returning a new array.</span>
<span class="kd">func</span> <span class="nf">appending</span><span class="p">(</span><span class="kd">@ArrayBuilder</span><span class="o">&lt;</span><span class="kt">Element</span><span class="o">&gt;</span> <span class="nv">builder</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Element</span><span class="p">]</span>
</code></pre>
<h3 id='extensions' class='heading'>Extensions</h3>

<p>All extensions are summarized per type, click on the typename to view it&rsquo;s extensions.</p>

<details><summary><strong>Array</strong></summary>
<p>

#### `Array.firstMap`

&ldquo;`swift
/// Find the first element that can map to a certain type, it&rsquo;s like doing a `.compactMap {}.first` 
/// without the overhead of mapping all values first.
/// - Parameter predicate: The predicate to match and map the value.
/// - Throws: Only rethrows.
/// - Returns: The first value that the predicate matched.
func firstMap<T>(where predicate: (Element) throws -> T?) rethrows -> T?
&rdquo;`

</p>
</details>

<details><summary><strong>Sequence</strong></summary>
<p>

#### `Sequence.unique`

&ldquo;`swift
/// Elements of this sequence in the same order but with elements having the same identifier
/// (as given by a closure) occurring only once.
///
/// &rdquo;`
/// let countries = [
///     (&ldquo;JP&rdquo;, &ldquo;Japan&rdquo;, &ldquo;Tokyo&rdquo;), (&ldquo;JP&rdquo;, &ldquo;Japan&rdquo;, &ldquo;Osaka&rdquo;),
///     (&ldquo;IT&rdquo;, &ldquo;Italy&rdquo;, &ldquo;Milan&rdquo;), (&ldquo;IT&rdquo;, &ldquo;Italy&rdquo;, &ldquo;Rome&rdquo;)
/// ]
/// print(countries.unique { $0.0 })
/// // Prints [(&ldquo;JP&rdquo;, &ldquo;Japan&rdquo;, &ldquo;Tokyo&rdquo;), (&ldquo;IT&rdquo;, &ldquo;Italy&rdquo;, &ldquo;Milan&rdquo;)]
/// &ldquo;`
///
/// - Parameter elementId: A closure providing identifier for every element of the sequence.
func unique<Identifier: Hashable>(by elementId: (Element) -> Identifier) -> [Element]
&rdquo;`

</p>
</details>

<details><summary><strong>Error & NSError</strong></summary>
<p>

#### `Error.mmm_description + NSError.mmm_description`

> **Note:** Also works on `Optional<Error>`.

&ldquo;`swift
/// Better string representation for `Error` and `NSError`s.
///
/// This is a Swift version of `mmm_description` that allows to avoid casting to `NSError`
/// and which falls back `String(describing:)` for &quot;not really&rdquo; `NSError`s to avoid meaningless
/// &ldquo;The operation couldn&rsquo;t be completed&rdquo; messages.
var mmm_description: String { get }
&ldquo;`

#### `NSError.mmm_underlyingError`

&rdquo;`swift
/// A shortcut fetching the underlying error.
func mmm_underlyingError() -> Error?
&ldquo;`

#### `NSError.init`

&rdquo;`swift
/// Initialize using the given value&rsquo;s type name as a domain string.
init(domain: Any, message: String, code: Int = -1, underlyingError: Error? = nil)
&ldquo;`

#### `NSError.mmm_error`

&rdquo;`swift
/// A convenience initializer accepting an underlying error as a parameter (can be nil).
class func mmm_error(withDomain domain: String, code: Int, message: String, underlyingError: Error?) -> Error

/// An initializer with the code being optional (set to -1, so is not displayed by mmm_description).
class func mmm_error(withDomain domain: String, message: String, underlyingError: Error?) -> Error

/// Another initializer hiding both the code (setting it to -1) and the underlyingError.
class func mmm_error(withDomain domain: String, message: String) -> Error
&ldquo;`


</p>
</details>

<details><summary><strong>Optional</strong></summary>
<p>

#### `Optional.unwrapped`

&rdquo;`swift
/// Execute the callback when the optional is non-nil.
/// - Parameter execute: The callback to be executed.
/// - Returns: Self for chaining
@discardableResult
func unwrapped(_ execute: (Wrapped) throws -> Void) rethrows -> Optional<Wrapped>
&ldquo;`

#### `Optional.unwrap(orThrow:)`

&rdquo;`swift
/// Unwrap an optional value, or throw the provided error when `nil`
/// - Returns: `Wrapped` value.
func unwrap<E: Error>(orThrow error: @autoclosure () -> E) throws -> Wrapped
&ldquo;`

#### `Optional.unwrap(withFallback:)`

&rdquo;`swift
/// Unwrap an optional value, or return the provided fallback value. Basically the same as 
/// using a the `??` operator with a non-optional value, that might look strange, or get 
/// lost in a long chain.
/// - Returns: `Wrapped` value if not nil, or `fallback`.
func unwrap(withFallback fallback: @autoclosure () -> Wrapped) -> Wrapped
&ldquo;`

</p>
</details>

<details><summary><strong>String</strong></summary>
<p>

#### `String.mmm_stringBySubstitutingVariables`

&rdquo;`swift
/// Swift (`String`) version for replacing `${variable_name}` with a value from a providing dictionary.
///
/// **Example**
/// &ldquo;`
/// let str = &quot;String with ${VARIABLES} in it, supports ${MULTIPLE} variables.&rdquo;
/// str.mmm_stringBySubstitutingVariables([
///     &ldquo;VARIABLES&rdquo;: &ldquo;Foo&rdquo;,
///     &ldquo;MULTIPLE&rdquo;: &ldquo;Bar&rdquo;
/// ]) // String with Foo in it, supports Bar variables.
/// &ldquo;`
func mmm_stringBySubstitutingVariables(_ variables: [String: String]) -> String
&rdquo;`

</p>
</details>

<details><summary><strong>Scanner</strong></summary>
<p>

#### `Scanner.mmm_scanNextCharacter`

&ldquo;`swift
/// Scans a single character unless at the end (or a null-terminator).
///
/// - Note: This is needed only before iOS 13, which has a corresponding shortcut.
func mmm_scanNextCharacter() -> Character?
&rdquo;`

#### `Scanner.mmm_scanString`

&ldquo;`swift
/// Scans the given strings if it follows next.
///
/// - Note: This is needed only before iOS 13, which has a corresponding shortcut.
func mmm_scanString(_ s: String) -> Bool
&rdquo;`

</p>
</details>

<details><summary><strong>NSDictionary</strong></summary>
<p>

#### `NSDictionary.mmm_extended`

&ldquo;`swift
/// A dictionary built from the receiver by adding values from another dictionary. The other 
/// dictionary can be nil. This is to make it more convenient to add stuff to literal 
/// dictionaries, such as Auto Layout metrics dictionaries or CoreText attribute dictionaries. 
func mmm_extended(with d: [AnyHashable : Any]) -> [AnyHashable : Any]
&rdquo;`

</p>
</details>

<details><summary><strong>NSMutableCharacterSet</strong></summary>
<p>

#### `NSMutableCharacterSet.mmm_addCharacters`

&ldquo;`swift
/// Convenience shortcut for `addCharactersInRange`. Adds a range of characters from first 
/// to last (including them both).
func mmm_addCharacters(from fist: unichar, to last: unichar)
&rdquo;`

</p>
</details>

<details><summary><strong>NSObject</strong></summary>
<p>

#### `NSObject.mmm_stripNSNull`

&ldquo;`swift
/// The receiver itself, or nil, if the receiver is [NSNull null].
func mmm_stripNSNull() -> Any
&rdquo;`

</p>
</details>

<details><summary><strong>NSString</strong></summary>
<p>

#### `NSString.mmm_string(bySubstitutingVariables:)`

&ldquo;`swift
/// Returns a string with variables in the form `${variable_name}` being replaced with values 
/// from the provided dictionary under the keys corresponding to &quot;variable_name&rdquo;. This is handy
/// for translatable strings, where the order of arguments might change and we don&rsquo;t want to use
/// tricky syntax of `stringWithFormat:`.
///
/// Note that keys are currently case-sensitive and the implementation is not very efficient, 
/// i.e. it should not be used with very long text.
func mmm_string(bySubstitutingVariables vars: [AnyHashable : Any]) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>NSDate</strong></summary>
<p>

#### `NSDate.mmm_date(withInternetTime:)`

&rdquo;`swift
/// NSDate from internet timestamps, ISO8601-like strings like &ldquo;2016-10-22T10:23:28Z&rdquo;. 
/// We support &ldquo;Internet profile&rdquo; of ISO8601, as described in RFC3339, and also allow 
/// the timezone or field separators to be absent.
class func mmm_date(withInternetTime s: String) -> Date
&ldquo;`

</p>
</details>

<details><summary><strong>NSArray</strong></summary>
<p>

#### `NSArray.mmm_arrayOfSlices`

&rdquo;`swift
/// The original array cut into subarrays with each slice except perhaps the last one 
/// consisting of maxLength elements.
func mmm_arrayOfSlices(withMaxLength maxLength: Int) -> [Any]
&ldquo;`

#### `NSArray.mmm_forEachPair`

&rdquo;`swift
/// Performs the given block for each pair of the elements of the array from left to right,
/// like (a[0], [1]), then (a[1], [2]), etc, i.e. every element except for the first and 
/// the last will participate in two pairs.
func mmm_forEachPair(_ block: (Any, Any) -> Void)
&ldquo;`

</p>
</details>

<details><summary><strong>NSData</strong></summary>
<p>

#### `NSData.mmm_data(withHexEncodedString:)`

&rdquo;`swift
/// NSData object with a hex-encoded string. E.e. @&ldquo;001213&rdquo; will give NSData consisting of 
/// 3 bytes 0x00, 0x12, and 0x13. This is handy for unit tests where NSData objects are 
/// expected.
/// 
/// Note that we ignore any non-hex characters between individual bytes, so you can insert
/// spaces, for example.
class func mmm_data(withHexEncodedString string: String) -> Any
&ldquo;`

</p>
</details>
<h3 id='global-functions' class='heading'>Global Functions</h3>

<p>All functions are summarized by function name, click on a function for more info.</p>

<details><summary><strong>MMMTypeName()</strong></summary>
<p>

&rdquo;`swift
/// The name of the value&rsquo;s type suitable for logs or NSError domains: without the name of the module
/// and/or private contexts.
public func MMMTypeName(_ value: Any) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>withParent()</strong></summary>
<p>

&rdquo;`swift
/// Unwraps the given &ldquo;parent&rdquo; object and either executes the given closure with it or, if the parent is `nil`,
/// triggers `preconditionFailure()` with a corresponding message.
///
/// This is handy for objects that keep a weak reference to their &ldquo;parent&rdquo; object and depend on it for certain
/// operations. Normally these objects should not be used when their parent is deallocated, but it could be handy
/// to flag such misuse. Using a guard with a corresponding preconditionFailure() is fine, but can be repetitive
/// especially if a nicer message is wanted.
public func withParent<Parent, ReturnType>(
    _ parent: Parent?,
    function: StaticString = #function, file: StaticString = #file, line: UInt = #line,
    block: (Parent) -> ReturnType
) -> ReturnType
&ldquo;`

</p>
</details>

<details><summary><strong>MMMLocalizedString()</strong></summary>
<p>

&rdquo;`swift
/// `NSLocalizedString()` without `comment` and with an optional dictionary of `${VAR}` substitutions
/// (see `mmm_stringBySubstitutingVariables`).
public func MMMLocalizedString(_ key: String, vars: [String: String]? = nil) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>MMMIsSystemVersionGreaterOrEqual()</strong></summary>
<p>

&rdquo;`swift
/// `true`, if the current iOS version is greater or equal to the provided version string.
public func MMMIsSystemVersionGreaterOrEqual(_ version: String) -> Bool
&ldquo;`

</p>
</details>

<details><summary><strong>MMMPathRelativeToAppBundle()</strong></summary>
<p>

&rdquo;`swift
/// For a path in one of the known subfolders of the app&rsquo;s sandbox (such as Library or Caches) 
/// returns a relative path prefixed with tokens like <Library> or <Bundle>. Returns the path 
/// unchanged in case it does not seem to be in a known folder.
/// 
/// Simple comparison is performed, the path is not normalized beforehand, etc. 
/// This is used only for direct output to logs, i.e. it&rsquo;s human readable and the format should
/// not be relied upon.
public func MMMPathRelativeToAppBundle(_ path: String) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>MMMCurlStringFromRequest()</strong></summary>
<p>

&rdquo;`swift
/// Roughly a curl-equivalent string for the given request. 
/// It&rsquo;s handy to dump all the outgoing requests this way.
public func MMMCurlStringFromRequest(_ request: URLRequest) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>MMMStringForLoggingFromData()</strong></summary>
<p>

&rdquo;`swift
/// A string version of the given NSData object suitable for logging. Typically used with
/// network responses, when we get something we cannot even parse, then we log at least
/// the beginning of it.
/// 
/// We try to interpret it as a UTF-8 encoded string first, and if it&rsquo;s not possible, then
/// resort to a hex dump. The result will be shorter than `maxStringLength` characters 
/// (unless this parameter is unreasonably small) and an ellipsis will be added in case of
/// truncation.
public func MMMStringForLoggingFromData(_ data: Data, _ maxStringLength: Int) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>MMMQueryStringFromParameters()</strong></summary>
<p>

&rdquo;`swift
/// Properly escaped URL query string from a dictionary of key-value pairs.
/// The keys are sorted alphabetically, so the same result is produced for the same dictionary.
public func MMMQueryStringFromParameters(_ parameters: [String : String]) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>MMMQueryStringFromParametersEscape()</strong></summary>
<p>

&rdquo;`swift
/// The function that is used by MMMQueryStringFromParameters() to escape parameter
/// names or values.
public func MMMQueryStringFromParametersEscape(_ s: String) -> String
&ldquo;`

</p>
</details>

<details><summary><strong>MMMSeemsLikeEmail()</strong></summary>
<p>

&rdquo;`swift
/// `true`, if the given string might be an email address.
///
/// This is not a validation but a basic sanity check: only checking for the presence
/// of at least one &lsquo;@&rsquo; and at least one dot character.
public func MMMSeemsLikeEmail(_ email: String) -> Bool
&ldquo;`

</p>
</details>
<h2 id='ready-for-liftoff' class='heading'>Ready for liftoff? 🚀</h2>

<p>We&rsquo;re always looking for talent. Join one of the fastest-growing rocket ships in
the business. Head over to our <a href="https://media.monks.com/careers">careers page</a>
for more info!</p>

          </div>
        </section>


      </article>
    </div>
    <section class="footer">
      <p>&copy; 2023 <a class="link" href="https://media.monks.com" target="_blank" rel="external noopener">Media.Monks</a>. All rights reserved. (Last updated: 2023-06-30)</p>
      <p></p>
    </section>
  </body>
</html>
